# Конкретное ФИО - ключ внешнего словаря
# Дальше ключи  вложенного словаря-значения

# пока возраст сделала как текст - подумать потом как лучше для последующей выборки, 
# на каком этапе переводить в число
staff = {
    "Иванов П.С.": {
        "ТН": "001",
        "Дата рождения": "17.10.1980", 
        "Адрес":"ул. Ленина, 43",
        "Пол":"М",
        "Возраст": '42',
        "Телефон":"+876390444",
        "Должность": "Директор",
        "Оклад": 150000,
        "Отдел": "Администрация",
        "Стаж": 22,
        "email": "ips1980@gmail.com",
        "Дата приема": '14.02.2005'
    },
    "Сергеева З.Л.": {
        "ТН": "002",
        "Дата рождения": "27.11.1983", 
        "Адрес":"ул. Попова, 15",
        "Пол":"Ж",
        "Возраст": '39',
        "Телефон":"+79121451402",
        "Должность": "Главный бухгалтер",
        "Оклад": 100000,
        "Отдел": "Бухгалтерия",
        "Стаж": 18,
        "email": "sergeeva@gmail.com",
        "Дата приема": '14.12.2010'
    },
    "Григорьева Е.С.": {
        "ТН": "003",
        "Дата рождения": "27.07.1982", 
        "Адрес":"ул. Просторная, 15-75",
        "Пол":"Ж",
        "Возраст": '40',
        "Телефон":"+79435558888",
        "Должность": "Коммерческий директор",
        "Оклад": 110000,
        "Отдел": "Администрация",
        "Стаж": 20,
        "email": "es_grig@gmail.com",
        "Дата приема": '25.02.2015'
    },
    "Тимофеев А.П.": {
        "ТН": "004",
        "Дата рождения": "21.05.1980", 
        "Адрес":"ул. Пушкинская, 22-48",
        "Пол":"М",
        "Возраст": '42',
        "Телефон":"+79254445566",
        "Должность": "Зав.производством",
        "Оклад": 120000,
        "Отдел": "Администрация",
        "Стаж": 22,
        "email": "timofeev@gmail.com",
        "Дата приема": '14.04.2007'
    }
}

# задать глобально список полей карточки сотрудника, чтобы его выводить в печать, также он потребуется при парсинге строки,
#  и при добавлении нового сотрудника - по списку пробегать и добавлять ключи в значение к нов.сотру
all_fields = ["ТН","Дата рождения","Адрес","Пол","Возраст","Телефон","Должность","Оклад","Отдел","Стаж","email","Дата приема"]
   

# при добавлении сотрудника нужно запрашивать все значения по порядку вложенных ключей,
# давать возможность пропустить заполнение, тогда его просто не будет или пустое
# чтоб можно было дозаполнить позже/ или автоматически заполнять пропуски "-"

# подумать, кто может добавить поле в карточку сотрудника - речь про ключ, а не про значение
# вести проверку на ввод ключа - при несовпадении не давать, кроме какой-то роли, например

# печатает просто список сотрудников
def print_list_worker(staff):
    print('Сотрудники:\n ')
    for k in staff:
        print(f'{k}')

# печатает список сотров с полными данными - всю базу последовательно по каждому сотру
def print_all_data(staff):
    for k,v in staff.items():
        print(f'\nФИО сотрудника: {k}')
        for m,n in v.items():
            print(f'\t{m}: {n}')


# преобразуем строку выбора полей в список
def str_to_li_fields(str_select):
        # парсим строку
    li_fields = str_select.split(',')
    # убираем пробелы
    li_fields = list(map((lambda el : el.strip() ),li_fields))
    #  проверка на соответствие списку полей
    for el in li_fields:
        if el not in all_fields:
            return False

    print(li_fields)
    return li_fields

# можно запрашивать через графич.интерфейс или хотя бы через запятую список полей для вывода
# и на основе этого списка формировать таблицу. Длину полей заголовков и значений задать словарем или иной структурой
def print_select_fields(staff, li_fields):
    # создать структуру,где каждому ключу соответствует длина строки. например словарь длины строки
    len_field = {
        "ТН": 3,
        "Дата рождения": 10, 
        "Адрес":20,
        "Пол":3,
        "Возраст": 7,
        "Телефон":12,
        "Должность": 20,
        "Оклад": 6,
        "Отдел": 15,
        "Стаж": 4,
        "email": 20,
        "Дата приема": 10
    }
    # сформировать вывод  - собираем заголовок таблицы
    first_str = '\nФИО:'.ljust(15)
    for el in li_fields:
        first_str += str(el).ljust(len_field[el])+'\t'
    print(first_str)    

    for k, v in staff.items():
        str_item = str(k).ljust(15)
        for el in li_fields:
            str_item+=str(v[el]).ljust(len_field[el])+'\t'
        print(str_item)


# печатает все данные по найденному сотруднику
def print_all_for_worker(dict,key):
    if key in dict:
        print(f'\nФИО сотрудника: {key}')
        for m,n in dict[key].items():
            print(f'\t{m}: {n}')
    else: print('Такой сотрудник не найден')  

#печатаем возможные для выборки поля у сотрудника - для информирования перед выбором
def print_fields_for_choice():
    # задать глобально список полей, здесь его выводить в печать, также он потребуется при парсинге строки
    print('Возможные поля для выборки:\n' , all_fields)


#по отделу, по должности, по полу и .тд.,т.е. по конкретному значению вложенного ключа
# сейчас печатает только ФИО и ТН - можно добавить флаг
# 1 - печатать только ФИО по выбранному параметру
# 2- печатать все данные по тем сотр-м, кот.соответствуют условию отбора
# без передачи параметров сделать флаг в ф-ции по умолчанию - только ФИО ТН, например
def print_for_key_value(dict, key, item):
    print('\nДанные по запросу - ', key, "=" ,item,":")
    count_find = 0
    for k in dict:
        if key in dict[k]: #если искомый ключ есть во вложенном словаре сотрудника
            if dict[k][key] == item: #если значение этого ключа совпадает с искомым
                print(f'ФИО: {k} \tТН: {dict[k]["ТН"]}')
                count_find+=1
                # доработать, если ключ сложный, типа ДР или Дата Приема или диапазон, тогда
                # добавить парсинг строки и/или сравнение значений
        # else:
        #      #фиксируем ошибку ввода для поиска полей
        # эта проверка должна идти на уровне ввода, так правильнее и иначе будет повторение вывода
        #     print('Некорректное поле для поиска') 
    if count_find == 0: 
        #фиксируем лог и
        print('По заданным параметрам ничего не найдено') 


# просто список со значениями конкретного ключа у всех - без выбора значения
def list_items_for_key(dict, key):
    print('\nДанные по запросу - ', key, ":")
    for k in dict:
        if key in dict[k]: #если искомый ключ есть во вложенном словаре сотрудника
            print(f'ТН: {dict[k]["ТН"]} \tФИО: {k} \t{key}: {dict[k][key]}')


print('Выводим последовательно все данные каждого сотрудника:')
print_all_data(staff)
# print('Печатаем просто список сотрудников:')
# print_list_worker(staff)
# # выводим все по сотруднику
# sotr = input('Выберите сотрудника, введите ФИО из списка:')     
# print_all_for_worker(staff, sotr)     

# #по отделу, по должности, по полу и .тд.,т.е. по значению конкретного вложенного ключа
# # сначала показываем все поля для выбора
# print_fields_for_choice()
# # после выбора поля на уровне интерфейса проверить корректность ввода, если это будет не строго ограниченный
# # выбор через GUI - есть ли вообще такое поле, а уже потом запрашивать значение
# section = input('Выберите/Введите поле для поиска: ') #если через GUI - дать возможность выбора 
# # после выбора поля логично по некоторым ключам показать их возможные значения для праивльного выбора,
# # т.е. к примеру, если section - Пол, дальше даем выбор конкретно между М и Ж и т.д.
# # а некоторые эл-ты вводятся, такие как цифры и даты
# el = input('Введите интересующее вас значение: ')
# print_for_key_value(staff, section, el)

# # просто список с разными значениями конкретного ключа у всех - без выбора значения
# #  - сделать
print_fields_for_choice()
# key = input('Введите интересующее вас поле для выборки значений: ')    
# list_items_for_key(staff,key)

# здесь на уровне интерфейса нужна проверка, чтоб разделители были запятые, а не точки
# или может даже в этом пункте меню - когда список формируем по заданным полям -
# есть смысл парсить строку сразу и проверять, входит ли каждый эл-т в список возможных полей - 
# этот список задать вручную - и возвращать уже список полей, а не строку
str_fields = input('Перечислите через запятую интересующие вас поля для выборки дынных: ')
# проверяем, если строка полей корректна
li_select = str_to_li_fields(str_fields)
if li_select:
    print_select_fields(staff, li_select)
    # передается база и список полей для вывода - парсинг строки проходит отдельной ф-цией
else:
    # здесь вызываем запись лога ошибки и выводим на экран
    print('Некорректный ввод')
    
# для печати всех полей таблицей можно использовать эту же ф-цию, только передавать в нее список всех полей all_fields
print('\nВыводим таблицу всех полей сотрудников:')
print_select_fields(staff, all_fields)